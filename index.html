<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Renderer Example</title>
    <style>
        /* Ensure the canvas fills the window */
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #glCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>
<body>
    <!-- Canvas element -->
    <canvas id="glCanvas"></canvas>

    <!-- Include gl-matrix library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>

    <!-- Your JavaScript code -->
    <script>
        // WebGLRenderer class to handle rendering
        class WebGLRenderer {
            constructor(params = {}) {
                this.canvas = params.canvas || document.createElement('canvas');
                this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
                if (!this.gl) {
                    alert("WebGL not supported, please use a different browser.");
                }
                this.camera = null;
                this.initialize();
            }

            initialize() {
                // Enable depth testing
                this.gl.enable(this.gl.DEPTH_TEST);

                // Set clear color
                this.gl.clearColor(0, 0, 0, 1);

                // Handle window resize
                window.addEventListener('resize', () => this.onResize());
                this.onResize();
            }

            onResize() {
                this.canvas.width = this.canvas.clientWidth;
                this.canvas.height = this.canvas.clientHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                if (this.camera) {
                    this.camera.updateProjectionMatrix();
                }
            }

            setSize(width, height) {
                this.canvas.width = width;
                this.canvas.height = height;
                this.gl.viewport(0, 0, width, height);
                if (this.camera) {
                    this.camera.updateProjectionMatrix();
                }
            }

            render(scene, camera) {
                this.camera = camera;
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                scene.traverse((object) => {
                    if (object instanceof Mesh) {
                        object.draw(this.gl, camera);
                    }
                });
            }
        }

        // Scene class to hold objects
        class Scene {
            constructor() {
                this.children = [];
            }

            add(object) {
                this.children.push(object);
            }

            traverse(callback) {
                this.children.forEach(callback);
            }
        }

        // Base class for geometries
        class Geometry {
            constructor() {
                this.vertices = [];
                this.indices = [];
                this.uvs = [];
                this.normals = [];
            }
        }

        // PlaneGeometry class
        class PlaneGeometry extends Geometry {
            constructor(width = 1, height = 1) {
                super();
                const w = width / 2;
                const h = height / 2;
                this.vertices = new Float32Array([
                    -w, -h, 0,
                     w, -h, 0,
                     w,  h, 0,
                    -w,  h, 0,
                ]);
                this.indices = new Uint16Array([
                    0, 1, 2,
                    2, 3, 0,
                ]);
                this.uvs = new Float32Array([
                    0, 0,
                    1, 0,
                    1, 1,
                    0, 1,
                ]);
                this.normals = new Float32Array([
                    0, 0, 1, // Normal for vertex 0
                    0, 0, 1, // Normal for vertex 1
                    0, 0, 1, // Normal for vertex 2
                    0, 0, 1, // Normal for vertex 3
                ]);
            }
        }

        // Base class for materials
        class Material {
            constructor() {
                this.program = null;
                this.uniforms = {};
            }

            compile(gl) {
                // To be implemented in subclasses
            }
        }

        // MeshBasicMaterial class
        class MeshBasicMaterial extends Material {
            constructor(params = {}) {
                super();
                this.color = params.color || [1, 1, 1, 1];
                this.vertexShaderSrc = `
                    attribute vec3 a_position;
                    uniform mat4 u_projectionMatrix;
                    uniform mat4 u_viewMatrix;
                    uniform mat4 u_modelMatrix;
                    void main() {
                        gl_Position = u_projectionMatrix * u_viewMatrix * u_modelMatrix * vec4(a_position, 1.0);
                    }
                `;
                this.fragmentShaderSrc = `
                    precision mediump float;
                    uniform vec4 u_color;
                    void main() {
                        gl_FragColor = u_color;
                    }
                `;
            }

            compile(gl) {
                // Compile shaders and create program
                const vertexShader = compileShader(gl, this.vertexShaderSrc, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(gl, this.fragmentShaderSrc, gl.FRAGMENT_SHADER);
                this.program = createProgram(gl, vertexShader, fragmentShader);
                // Get attribute and uniform locations
                this.attribLocations = {
                    position: gl.getAttribLocation(this.program, 'a_position'),
                };
                this.uniformLocations = {
                    projectionMatrix: gl.getUniformLocation(this.program, 'u_projectionMatrix'),
                    viewMatrix: gl.getUniformLocation(this.program, 'u_viewMatrix'),
                    modelMatrix: gl.getUniformLocation(this.program, 'u_modelMatrix'),
                    color: gl.getUniformLocation(this.program, 'u_color'),
                };
            }
        }

        // ShaderMaterial class
        class ShaderMaterial extends Material {
            constructor(params = {}) {
                super();
                this.vertexShaderSrc = params.vertexShader || '';
                this.fragmentShaderSrc = params.fragmentShader || '';
                this.uniforms = params.uniforms || {};
                this.attributes = params.attributes || {};
            }

            compile(gl) {
                // Compile shaders and create program
                const vertexShader = compileShader(gl, this.vertexShaderSrc, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(gl, this.fragmentShaderSrc, gl.FRAGMENT_SHADER);
                this.program = createProgram(gl, vertexShader, fragmentShader);

                // Get attribute locations
                this.attribLocations = {};
                for (let attribName in this.attributes) {
                    this.attribLocations[attribName] = gl.getAttribLocation(this.program, attribName);
                }

                // Get uniform locations
                this.uniformLocations = {};
                for (let uniformName in this.uniforms) {
                    this.uniformLocations[uniformName] = gl.getUniformLocation(this.program, uniformName);
                }
            }
        }

        // Mesh class
        class Mesh {
            constructor(geometry, material) {
                this.geometry = geometry;
                this.material = material;
                this.modelMatrix = mat4.create();
                this.buffers = {};
            }

            initBuffers(gl) {
                // Create and bind buffers
                this.buffers.position = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
                gl.bufferData(gl.ARRAY_BUFFER, this.geometry.vertices, gl.STATIC_DRAW);

                if (this.geometry.uvs.length > 0) {
                    this.buffers.uv = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.uv);
                    gl.bufferData(gl.ARRAY_BUFFER, this.geometry.uvs, gl.STATIC_DRAW);
                }

                if (this.geometry.normals.length > 0) {
                    this.buffers.normal = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.normal);
                    gl.bufferData(gl.ARRAY_BUFFER, this.geometry.normals, gl.STATIC_DRAW);
                }

                this.buffers.index = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.geometry.indices, gl.STATIC_DRAW);
            }

            draw(gl, camera) {
                if (!this.material.program) {
                    this.material.compile(gl);
                    this.initBuffers(gl);
                }

                gl.useProgram(this.material.program);

                // Set up attributes
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
                gl.enableVertexAttribArray(this.material.attribLocations.position);
                gl.vertexAttribPointer(this.material.attribLocations.position, 3, gl.FLOAT, false, 0, 0);

                // Set up uniforms
                gl.uniformMatrix4fv(this.material.uniformLocations.projectionMatrix, false, camera.projectionMatrix);
                gl.uniformMatrix4fv(this.material.uniformLocations.viewMatrix, false, camera.viewMatrix);
                gl.uniformMatrix4fv(this.material.uniformLocations.modelMatrix, false, this.modelMatrix);

                if (this.material.uniformLocations.color) {
                    gl.uniform4fv(this.material.uniformLocations.color, this.material.color);
                }

                // Bind index buffer and draw
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
                gl.drawElements(gl.TRIANGLES, this.geometry.indices.length, gl.UNSIGNED_SHORT, 0);
            }
        }

        // OrthographicCamera class
        class OrthographicCamera {
            constructor(left, right, top, bottom, near = 0.1, far = 1000) {
                this.left = left;
                this.right = right;
                this.top = top;
                this.bottom = bottom;
                this.near = near;
                this.far = far;
                this.zoom = 1;
                this.position = [0, 0, 5];
                this.projectionMatrix = mat4.create();
                this.viewMatrix = mat4.create();
                this.updateProjectionMatrix();
                this.updateViewMatrix();
            }

            updateProjectionMatrix() {
                mat4.ortho(
                    this.projectionMatrix,
                    this.left / this.zoom,
                    this.right / this.zoom,
                    this.bottom / this.zoom,
                    this.top / this.zoom,
                    this.near,
                    this.far
                );
            }

            updateViewMatrix() {
                mat4.identity(this.viewMatrix);
                mat4.translate(this.viewMatrix, this.viewMatrix, [-this.position[0], -this.position[1], -this.position[2]]);
            }

            pan(dx, dy) {
                this.position[0] -= dx * this.zoom;
                this.position[1] += dy * this.zoom;
                this.updateViewMatrix();
            }

            zoomIn(factor) {
                this.zoom *= factor;
                this.updateProjectionMatrix();
            }

            zoomOut(factor) {
                this.zoom /= factor;
                this.updateProjectionMatrix();
            }
        }

        // Utility functions
        function compileShader(gl, shaderSource, shaderType) {
            const shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);
            const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!success) {
                console.error('Shader compilation failed:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            const success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!success) {
                console.error('Program linking failed:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Get the canvas element
        const canvas = document.getElementById('glCanvas');

        // Initialize renderer
        const renderer = new WebGLRenderer({ canvas });

        // Create scene
        const scene = new Scene();

        // Create camera
        function updateCameraAspect() {
            const aspect = canvas.clientWidth / canvas.clientHeight;
            camera.left = -aspect;
            camera.right = aspect;
            camera.updateProjectionMatrix();
        }
        const camera = new OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
        updateCameraAspect();
        window.addEventListener('resize', updateCameraAspect);

        // Create geometry and material
        const geometry = new PlaneGeometry(2, 2);
        const material = new MeshBasicMaterial({ color: [0.2, 0.5, 0.8, 1] });

        // Create mesh and add to scene
        const mesh = new Mesh(geometry, material);
        scene.add(mesh);

        // Render loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();

        // Implement pan and zoom controls
        let isDragging = false;
        let lastX, lastY;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = (e.clientX - lastX) / canvas.clientWidth * 2;
                const dy = (e.clientY - lastY) / canvas.clientHeight * 2;
                camera.pan(dx, dy);
                lastX = e.clientX;
                lastY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                camera.zoomIn(1.1);
            } else {
                camera.zoomOut(1.1);
            }
        });

        // Ensure the canvas size matches its display size
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;

            if (canvas.width !== displayWidth ||
                canvas.height !== displayHeight) {

                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                renderer.setSize(displayWidth, displayHeight);
                if (camera) {
                    updateCameraAspect();
                }
            }
        }

        // Resize the canvas on window resize
        window.addEventListener('resize', () => {
            resizeCanvasToDisplaySize(canvas);
        });

        // Initial resize
        resizeCanvasToDisplaySize(canvas);
    </script>
</body>
</html>
